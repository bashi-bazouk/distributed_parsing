open List
open Hashtbl

type ('k,'v) index = ('k,'v) Hashtbl.t

let least_fixpoint ?eq:(eq=(=)) op x =
	let curr = ref x
	and next = ref (op x) in
	while not (eq !curr !next) do
		curr := !next;
		next := op !curr;
	done;
	!curr

let rec update (l: 'a list) = function
	| [] -> l
	| hd::tl ->
		if List.mem hd l then
			update (hd::l) tl
		else
			update l tl

let deduplicate (l: 'a list) =
	update [] l

module type T = sig

	type t
	type nt

	type sequent =
		| T of t
		| NT of nt

	type sequents = t list * nt list

	type sequence = sequent list

	type production = nt * sequence

	type disjunction = sequence list

	type grammar = (nt, disjunction) index
	
	val empty_grammar: grammar

	val (|-): grammar -> nt -> disjunction



	val sequents_of_grammar: grammar -> sequents

	val terminals: grammar -> t list
	val nonterminals: grammar -> nt list

end


module Make = struct

	type t
	type nt

	type sequent =
		| T of t
		| NT of nt

	type sequents = t list * nt list

	type sequence = sequent list

	type production = nt * sequence

	type disjunction = sequence list

	type grammar = (nt, disjunction) index


	(* Lookups *)

	let empty_grammar = Hashtbl.create 0


	let (|-) (grammar: grammar) (nonterminal: nt): disjunction =
		try
			find grammar nonterminal
		with Not_found -> []


	(* Constructors *)

	let (:=) (nt: nt) (disjunction: disjunction): grammar = 
		let grammar = Hashtbl.create 1 in
		Hashtbl.add grammar nt disjunction;
		grammar


	let (++) (g: grammar) (g': grammar): grammar =
		let g'' = Hashtbl.create 16
		and union d d' = fold_right (fun s d'' -> if List.mem s d'' then d'' else s::d'') d' d in
		iter (fun nonterminal disjunction ->
			replace g'' nonterminal (union (g |- nonterminal) disjunction)
		) g';
		g''

	let union = fold_left (++) empty_grammar


	let (--) (grammar: grammar) (subgrammar: grammar): grammar =
		fold (fun nonterminal disjunction complement ->
			let complementary_disjunction =
				let subgrammar_disjunction = subgrammar |- nonterminal in
				filter (fun sequence -> not (List.mem sequence subgrammar_disjunction)) disjunction in 
			if (List.length complementary_disjunction) > 0 then
				complement ++ (nonterminal := complementary_disjunction)
			else
				complement
		) empty_grammar grammar


	let symmetric_difference l r = (l -- r) ++ (r -- l)


	let intersection l r = (union [l; r]) -- (symmetric_difference l r)


	(* Sequents *)

	let sequents_of_grammar (grammar: grammar): sequents =
		let maybe_add s ss = if List.mem s ss then ss else ss@[s] in
		fold (fun nt disjunction (ts, nts) ->
			let nts = maybe_add nt nts in
			fold_left (fun (ts, nts) -> function
				| T t -> ((maybe_add t ts), nts)
				| NT nt -> (ts, (maybe_add nt nts))
			) (ts, nts) (concat disjunction)
		) grammar ([], [])

	let terminals grammar = fst (sequents_of_grammar grammar)
	let nonterminals grammar = snd (sequents_of_grammar grammar)


	(* Reachability *)

	let cocover (grammar: grammar) (nonterminals: nt list): nt list =
		(* cocover g nts returns the set of nonterminals pointed to by nts. *)
		List.fold_left (fun partial_cover nt ->
			let sequents = List.concat (grammar |- nt) in
			fold_left (fun partial_cover -> function 
				| T _ -> partial_cover
				| NT nt -> nt::partial_cover
			) partial_cover sequents
		) [] nonterminals


	let pushout (grammar: grammar) (subgrammar: grammar): grammar =
		(* pushout g g' returns the grammar generated by g' and (cocover g g'). *)
		let nonterminal_cocover = cocover grammar (nonterminals subgrammar) in
		let cocovering_disjunctions = map ((|-) grammar) nonterminal_cocover in
		let cocovering_rules = map2 (:=) nonterminal_cocover cocovering_disjunctions in
		let cocovering_grammar = union cocovering_rules in
		subgrammar ++ cocovering_grammar


	let reachable (grammar: grammar) (subgrammar: grammar): grammar =
		(* reachable g g' returns the the smallest idempotent pushout of g that covers g' *)
		least_fixpoint (pushout grammar) subgrammar


	(* Co-Reachability *)

	let cover (grammar: grammar) (nonterminals: nt list): nt list =
		(* cover g nts returns the set of nonterminals that point to nts. *)
		let recognized_nonterminal: sequent -> bool = function 
			| T _ -> false
			| NT nt -> List.mem nt nonterminals in
		fold (fun nonterminal disjunction nonterminal_cocover ->
			if exists (exists recognized_nonterminal) disjunction then
				nonterminal::nonterminal_cocover
			else
				nonterminal_cocover
		) grammar []


	let pullback (grammar: grammar) (subgrammar: grammar): grammar = 
		(* pullback g g' returns the grammar generated by g' and (cover g g') *)
		let nonterminal_cover = cover grammar (nonterminals subgrammar) in

		let recognized_nonterminal: sequent -> bool = function 
			| T _ -> false
			| NT nt -> List.mem nt nonterminal_cover in

		let covering_grammar = fold (fun nonterminal disjunction covering_grammar ->
			let covering_disjunction = filter (exists recognized_nonterminal) disjunction in
			if (List.length covering_disjunction) > 0 then
				(nonterminal := covering_disjunction) ++ covering_grammar
			else
				covering_grammar
		) grammar empty_grammar in

		subgrammar ++ covering_grammar


	let coreachable (grammar: grammar) (subgrammar: grammar): grammar =
		(* reachable g g' returns the the smallest idempotent pullback of g that cocovers g' *)
		least_fixpoint (pullback grammar) subgrammar


	let trim (grammar: grammar) (subgrammar: grammar): grammar =
		(* trim g g' returns a pullback/pushout idempotent subgrammar of g that covers and cocovers g'.*)
		let reachable = reachable grammar subgrammar
		and coreachable = coreachable grammar subgrammar in
		intersection reachable coreachable



	(* Adjacencies *)

	type 'a sequent_algebra = sequent -> sequent -> 'a

	let rec boundary_terminals (grammar: grammar) (nonterminal: nt): t list * t list =
		fold_left (fun (starts, ends) -> function
			| [] -> (starts, ends)
			| [NT nt] ->
				boundary_terminals grammar nt
			| [T t] ->
				([t], [t])
			| (NT nt)::tail ->
				let starts = fst (boundary_terminals grammar nt) in
				(match hd (rev tail) with
					| T t -> (starts, [t])
					| NT nt ->
						let ends = snd (boundary_terminals grammar nt) in
						(starts, ends))
			| (T t)::tail ->
				let starts = [t] in
				(match hd (rev tail) with
					| T t -> (starts, [t])
					| NT nt ->
						let ends = snd (boundary_terminals grammar nt) in
						(starts, ends))
		) ([], []) (grammar |- nonterminal)


	(*
	let left_adjacency (grammar: grammar): boolean t_algebra =
		(* (left_adjacency g) t t' returns true if g admits (T t) (T t') somewhere in the grammar *)
		let (terminals, nonterminals) = sequents_of_grammar grammar in
		let adjacency_table = Hashtbl.create (length terminals) in
		let index t = find adjacency_table t in
		let set_adjacent ?v(v=true) t t' = update (index t) t' v
		and t_algebra t t' = try find (index t) t' with Not_found -> false in

		(* Build the second indices of adjacency_table. *)
		iter (fun t -> add adjacency_table t (Hashtbl.create (length terminals)) terminals;

		(* Recursively set all of the possible adjacencies in the adjacency table *)
		let rec generate_adjacencies 
			?fix:(fix=[])
			(grammar: grammar)
			(nonterminal: nt)
			: t list * t list =

			let (starts, ends) = 
				boundary_terminals grammar nonterminal in

			if not (List.mem nonterminal fix) then
				(fold_left (fun (prevs) -> function
				| (T t)::_ ->
					@acc[t]
				| (NT nt)::_ ->
					let (starts, ends) = 
						generate_adjacencies ~fix:(nonterminal::fix) grammar nt in
				) starts (grammar |- nonterminal)
			else
				(starts, ends)

		iter (generate_adjacencies grammar) nonterminals


	


		let t_algebra = (fun t t' -> try find (index t) t' with Not_found -> false) in
		t_algebra
		

	*)
	(* Concurrencies *)




end