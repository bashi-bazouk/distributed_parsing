open List
open Hashtbl

type ('k,'v) index = ('k,'v) Hashtbl.t

let least_fixpoint ?eq:(eq=(=)) op x =
	let curr = ref x
	and next = ref (op x) in
	while not (eq !curr !next) do
		curr := !next;
		next := op !curr;
	done;
	!curr


module Make = struct

	type t
	type nt

	type sequent =
		| T of t
		| NT of nt

	type sequents = t list * nt list

	type sequence = sequent list

	type production = nt * sequence

	type disjunction = sequence list

	type grammar = (nt, disjunction) index


	(* Lookups *)

	let empty_grammar = Hashtbl.create 0


	let (|-) (grammar: grammar) (nonterminal: nt): disjunction =
		try
			find grammar nonterminal
		with Not_found -> []


	(* Constructors *)

	let (:=) (nt: nt) (disjunction: disjunction): grammar = 
		let grammar = Hashtbl.create 1 in
		Hashtbl.add grammar nt disjunction;
		grammar


	let (++) (g: grammar) (g': grammar): grammar =
		let g'' = Hashtbl.create 16
		and union d d' = fold_right (fun s d'' -> if List.mem s d'' then d'' else s::d'') d' d in
		iter (fun nonterminal disjunction ->
			replace g'' nonterminal (union (g |- nonterminal) disjunction)
		) g';
		g''

	let union = fold_left (++) empty_grammar


	let (--) (grammar: grammar) (subgrammar: grammar): grammar =
		fold (fun nonterminal disjunction complement ->
			let complementary_disjunction =
				let subgrammar_disjunction = subgrammar |- nonterminal in
				filter (fun sequence -> not (List.mem sequence subgrammar_disjunction)) disjunction in 
			if (List.length complementary_disjunction) > 0 then
				complement ++ (nonterminal := complementary_disjunction)
			else
				complement
		) empty_grammar grammar


	let symmetric_difference l r = (l -- r) ++ (r -- l)


	let intersection l r = (union [l; r]) -- (symmetric_difference l r)


	(* Sequents *)

	let sequents_of_grammar (grammar: grammar): sequents =
		let maybe_add s ss = if List.mem s ss then ss else ss@[s] in
		fold (fun nt disjunction (ts, nts) ->
			let nts = maybe_add nt nts in
			fold_left (fun (ts, nts) -> function
				| T t -> ((maybe_add t ts), nts)
				| NT nt -> (ts, (maybe_add nt nts))
			) (ts, nts) (concat disjunction)
		) grammar ([], [])

	let terminals grammar = fst (sequents_of_grammar grammar)
	let nonterminals grammar = snd (sequents_of_grammar grammar)


	(* Reachability *)

	let cocover (grammar: grammar) (nonterminals: nt list): nt list =
		(* cocover g nts returns the set of nonterminals pointed to by nts. *)
		List.fold_left (fun partial_cover nt ->
			let sequents = List.concat (grammar |- nt) in
			fold_left (fun partial_cover -> function 
				| T _ -> partial_cover
				| NT nt -> nt::partial_cover
			) partial_cover sequents
		) [] nonterminals


	let pushout (grammar: grammar) (subgrammar: grammar): grammar =
		(* pushout g g' returns the grammar generated by g' and (cover g g'). *)
		let nonterminal_cover = cover grammar (nonterminals subgrammar) in
		let covering_disjunctions = map ((|-) grammar) nonterminal_cover in
		let covering_rules = map2 (:=) nonterminal_cover covering_disjunctions in
		let covering_grammar = union covering_rules in
		subgrammar ++ covering_grammar


	let reachable (grammar: grammar) (subgrammar: grammar): grammar =
		(* reachable g g' returns the the smallest idempotent pushout of g that covers g' *)
		least_fixpoint (pushout grammar) subgrammar


	(* Co-Reachability *)

	let cover (grammar: grammar) (nonterminals: nt list): nt list =
		(* cover g nts returns the set of nonterminals that point to nts. *)
		let recognized_nonterminal: sequent -> bool = function 
			| T _ -> false
			| NT nt -> List.mem nt nonterminals in
		fold (fun nonterminal disjunction nonterminal_cocover ->
			if exists (exists recognized_nonterminal) disjunction then
				nonterminal::nonterminal_cocover
			else
				nonterminal_cocover
		) grammar []


	let pullback (grammar: grammar) (subgrammar: grammar): grammar = 
		(* pullback g g' returns the grammar generated by g' and (cocover g g') *)
		let nonterminal_cocover = cocover grammar (nonterminals subgrammar) in

		let recognized_nonterminal: sequent -> bool = function 
			| T _ -> false
			| NT nt -> List.mem nt nonterminal_cocover in

		let cocovering_grammar = fold (fun nonterminal disjunction cocovering_grammar ->
			let cocovering_disjunction = filter (exists recognized_nonterminal) disjunction in
			if (List.length cocovering_disjunction) > 0 then
				(nonterminal := cocovering_disjunction) ++ cocovering_grammar
			else
				cocovering_grammar
		) grammar empty_grammar in

		subgrammar ++ cocovering_grammar


	let coreachable (grammar: grammar) (subgrammar: grammar): grammar =
		(* reachable g g' returns the the smallest idempotent pullback of g that cocovers g' *)
		least_fixpoint (pullback grammar) subgrammar


	let trim (grammar: grammar) (subgrammar: grammar): grammar =
		(* trim g g' returns a pullback/pushout idempotent subgrammar of g that covers and cocovers g'.*)
		let reachable = reachable grammar subgrammar
		and coreachable = coreachable grammar subgrammar in
		intersection reachable coreachable



	












end